from __future__ import division, print_function

import numpy as np
from numpy.linalg import norm
from .restraint import Restraint
from ..model.forces import HarmonicUpperBound, HarmonicLowerBound
from ..model.particle import Particle

import h5py
from ..utils.log import logger

# helper functions

class PolymerDistrib(Restraint):

    """
    Object handles Polymer restraint, when distances are not uniform and/or follow a given distribution
    
    Parameters
    ----------
    assignment_file : h5df - file list generated by the Assignment Step
          struct_id : index of structure in population
               index: alabtools Index object
           tolerance: tolerance parameter to impose distances
             kspring: polymer restraining constant
    
    Read in a polymer_file generated from the AssignmentStep, apply restraintson all (i,i+1) distances
    """
    
    def __init__(self, 
                 polymer_assignment_file, 
                 struct_id,
                 index,
                 tolerance = 10.0, 
                 kspring = 2.0 ):
        
        self.polymer_assignment_file = polymer_assignment_file

        self.hff                  = h5py.File(self.polymer_assignment_file, 'r')
        self.index                = index
        self.struct_id            = struct_id
        self.tolerance            = tolerance
        self.kspring              = kspring
        
        # list to which FISH restraints are appended to the model object
        self.forceID   = []

        
    def _apply(self, model):
        
            # focus on a particular structure
            struct_id = self.struct_id

            ck        = self.kspring
            tol       = self.tolerance
            
            # this is the file from assignment
            hff       = self.hff

            #logger.info("tolerance = " + str(tol))
            #logger.info("crd      = " + str(crd.shape))
      
            locus   = hff['loci'][()]
            targets = hff['nn_dist'][:, struct_id][()]

            #logger.info(np.sort(targets))

            for q, i in enumerate(locus):

               target_dist = targets[q]

               # if i and i+1 are on the same chromosome (maybe add info about copy, just for the sake of it)
               if self.index.chrom[i] == self.index.chrom[i+1]:
                   
                   # add lower bound
                   f = model.addForce(HarmonicLowerBound((i, i+1), k = ck, d = max(0, target_dist - tol), note = Restraint.NEW_POLY))
                   self.forceID.append(f)

                   # add upper bound
                   f = model.addForce(HarmonicUpperBound((i, i+1), k = ck, d = target_dist + tol, note = Restraint.NEW_POLY))
                   self.forceID.append(f)
 
                   # overall, we are applying a full harmonic potential centered in target_dist, with a tolerance

            hff.close()
    
#==
